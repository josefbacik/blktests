#!/bin/bash
# SPDX-License-Identifier: GPL-3.0+
#
# Test io.latency to make sure it's protecting the higher priority group
# properly.

. tests/block/rc

DESCRIPTION="test the io.latency interface to make sure it's working right"

requires() {
	_have_cgroup2_controller_file io io.latency && _have_fio && \
		_have_program jq
}

_fio_results_key() {
	_job=$1
	_key=$2
	_resultfile=$3

	jq '.jobs[] | select(.jobname == "'${_job}'") | .'${_key} ${_resultfile}
}

test_device() {
	local fio_config_single fio_config_double fio_results fio_args qd

	fio_config_single=${TMPDIR}/single.fio
	fio_config_double=${TMPDIR}/double.fio
	fio_results=${TMPDIR}/029.json
	fio_args="--output-format=json --output=${fio_results}"
	qd=$(cat ${TEST_DEV_SYSFS}/queue/nr_requests)

	cat << EOF > "${fio_config_single}"
	[fast]
	filename=${TEST_DEV}
	direct=1
	allrandrepeat=1
	readwrite=randrw
	size=4G
	ioengine=libaio
	iodepth=${qd}
	fallocate=none
	randseed=12345
EOF

	cat << EOF > "${fio_config_double}"
	[global]
	filename=${TEST_DEV}
	direct=1
	allrandrepeat=1
	readwrite=randrw
	size=4G
	ioengine=libaio
	iodepth=${qd}
	fallocate=none
	randseed=12345

	[fast]
	cgroup=blktests/fast

	[slow]
	cgroup=blktests/slow
EOF
	# We run the test once so we have an idea of how fast this workload will
	# go with nobody else doing IO on the device.
	if ! fio ${fio_args} ${fio_config_single}; then
		echo "fio exited with status $?"
		return 1
	fi

	_time_taken=$(_fio_results_key fast job_runtime ${fio_results})
	if [ "${_time_taken}" = "" ]; then
		echo "fio doesn't report job_runtime"
		return 1
	fi

	echo "normal time taken ${_time_taken}" >> $FULL

	# There's no way to predict how the two workloads are going to affect
	# each other, so we weant to set thresholds to something reasonable so
	# we can verify io.latency is doing something.  This means we set 15%
	# for the fast cgroup, just to give us enough wiggle room as throttling
	# doesn't happen immediately.  But if we have a super fast disk we could
	# run both groups really fast and make it under our fast threshold, so
	# we need to set a threshold for the slow group at 50%.  We assume that
	# if it was faster than 50% of the fast threshold then we probably
	# didn't throttle and we can assume io.latency is broken.
	_fast_thresh=$((${_time_taken} + ${_time_taken} * 15 / 100))
	_slow_thresh=$((${_time_taken} + ${_time_taken} * 50 / 100))
	echo "fast threshold time is ${_fast_thresh}" >> $FULL
	echo "slow threshold time is ${_slow_thresh}" >> $FULL

	# Create the cgroup files
	_dir=$(_cgroup2_base_dir)/blktests
	echo "+io" > ${_dir}/cgroup.subtree_control
	mkdir ${_dir}/fast
	mkdir ${_dir}/slow

	# We set the target to 1usec because we could have a fast device that is
	# capable of remarkable IO latencies that would skew the test.  It needs
	# to be low enough that we do actually throttle the slow group,
	# otherwise the test will fail when there's nothing wrong.
	_major=$((0x$(stat -c "%t" ${TEST_DEV})))
	_minor=$((0x$(stat -c "%T" ${TEST_DEV})))
	echo "${_major}:${_minor} is our device" >> $FULL
	if ! echo "${_major}:${_minor} target=1" > ${_dir}/fast/io.latency; then
		echo "Failed to set our latency target"
		return 1
	fi

	if ! fio ${fio_args} ${fio_config_double}; then
		echo "fio exited with status $?"
		return 1
	fi

	_fast_time=$(_fio_results_key fast job_runtime ${fio_results})
	echo "Fast time ${_fast_time}" >> $FULL
	_slow_time=$(_fio_results_key slow job_runtime ${fio_results})
	echo "Slow time ${_slow_time}" >> $FULL

	if [ ${_fast_thresh} -lt ${_fast_time} ]; then
		echo "Too much of a performance drop for the protected workload"
		return 1
	fi

	if [ ${_slow_thresh} -gt ${_slow_time} ]; then
		echo "The slow group does not appear to have been throttled"
		return 1
	fi

	echo "Silence is golden"
	return 0
}
